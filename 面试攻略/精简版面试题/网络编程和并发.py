import time


"""
1.简述 OSI 七层协议

    1.物理层：
        定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。
    主要作用是传输比特流。
    
    2.数据链路层：
        定义了如何让格式化数据以进行传输。
    这一层通常还提供错误检测和纠正，以确保数据的可靠传输。
    
    3.网络层：
        在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。
    
    4.传输层：
        定义了一些传输数据的协议和端口号（WWW端口80等），比如：
        TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）。
        UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，
    如QQ聊天数据就是通过这种方式传输的）。           
        主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。
    
    5.会话层:
        通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。
        主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）

    6.表示层:
        可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
        
    7.应用层:
        是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。    


2.简述 三次握手、四次挥手的流程。

    三次握手：
        
        第一次握手：客户端（client）发送SYN包到服务器（server），
    客户端（client）状态机进入SYN_SEND状态，等待服务器确认；

        第二次握手：服务器（server）接收到SYN包，必须发送ACK包到客户端，
    同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态；

        第三次握手：客户端（client）接收到服务器发送的SYN+ACK包，
    必须向服务器发送确认包ACK，此包发送成功，则客户端和服务器同时进入ESTABLISHED状态。


    四次挥手：
        假设客户端发起断开连接请求，
        
        第一次挥手：客户端（client）发送FIN报文到Server端
        
        第二次挥手：服务器（server）收到客户端发送的FIN包之后，发送ACK包到客户端，
    客户端收到服务器发送的ACK之后，进入FIN_WAIT状态，等待server端发送FIN报文

        第三次挥手：服务器（server）发送FIN报文到客户端
        
        第四次挥手：客户端收到服务器发送的FIN报文之后，发送ACK包到服务器，
    服务器收到ACK之后即断开连接，等待一段时间TIME_WAIT之后，
    客户端发现服务器没有再发FIN过来，就知道服务器已经断开连接，此时客户端也进入断开连接状态。

        
3.什么是arp协议？
        地址解析协议，即ARP（Address ResoluTIon Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
    
        作用：因为在局域网中，如果源主机要和目的主机建立通信关系，
    那么源主机必须要知道目的主机的MAC地址（即硬件地址），但是如果目的主机或者源主机是第一次进行通信的，
    那么源主机要怎样才能知道目的主机的MAC地址呢？ 所以这样就引入了ARP地址协议。


4.TCP和UDP的区别？
        1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
        
        2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，
    且按序到达;UDP尽最大努力交付，即不保证可靠交付
        
        3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
    UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
        
        4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
        
        5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
        
        6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道


5.什么是局域网和广域网？
        一、局域网 
        
            局域网（Local Area Network），简称LAN，是指在某一区域内由多台计算机互联成的计算机组。
        “某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。局域网可以实现文件管理、
        应用软件共享、打印机共享、扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。
        局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 

        二、广域网 
            广域网（Wide Area Network），简称WAN，是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，
        甚至一个国家。
        广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网


6.为何基于tcp协议的通信比基于udp协议的通信更可靠？
            TCP的可靠保证，是它的三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。
        而UDP就没有了，udp信息发出后,不验证是否到达对方,所以不可靠。
        
        
 7.什么是socket？简述基于tcp协议的套接字通信流程。
            网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。
            
            基于tcp协议流程：
                1.服务器先用 socket 函数来建立一个套接字,用这个套接字完成通信的监听。 
                2.用 bind 函数来绑定一个端口号和 IP 地址。因为本地计算机可能有多个网址和 IP,每一个 IP 和端口有多个端口。
            需要指定一个 IP 和端口进行监听。 
                3.服务器调用 listen 函数,使服务器的这个端口和 IP 处于监听状态,等待客户机的连接。 
                
                4.客户机用 socket 函数建立一个套接字,设定远程 IP 和端口。 
                5.客户机调用 connect 函数连接远程计算机指定的端口。 
                
                6.服务器用 accept 函数来接受远程计算机的连接,建立起与客户机之间的通信。 
                
                7.建立连接以后,客户机用 write 函数向 socket 中写入数据。也可以用 read 函数读取服务器发送来的数据。 
                
                8.服务器用 read 函数读取客户机发送来的数据,也可以用 write 函数来发送数据。 
                9.完成通信以后,用 close 函数关闭 socket 连接。   
                        
                        
8.什么是粘包？ socket 中造成粘包的原因是什么？
            1 什么是粘包现象?
                TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
            
            2 为什么出现粘包现象
                （1）发送方原因
                    TCP默认会使用Nagle算法。而Nagle算法主要做两件事：
                    1）只有上一个分组得到确认，才会发送下一个分组；
                    2）收集多个小分组，在一个确认到来时一起发送。        
                        
                    所以，正是Nagle算法造成了发送方有可能造成粘包现象。
            
                （2）接收方原因
                    TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；
                    实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。
                这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，
                就会读到多个首尾相接粘到一起的包。
             
            3 什么时候需要处理粘包现象
                1）如果发送方发送的多个分组本来就是同一个数据的不同部分，         
            比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；
        
                （2）但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。
            比如，我当时要接收的每个分组都是一个有固定格式的商品信息，
            如果不处理粘包问题，每个读进来的分组我只会处理最前边的那个商品，后边的就会被丢弃。这显然不是我要的结果。
        
            4 如何处理粘包现象
                （1）发送方
                对于发送方造成的粘包现象，我们可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭Nagle算法。
                
                （2）接收方
                遗憾的是TCP并没有处理接收方粘包现象的机制，我们只能在应用层进行处理。
                
                （3）应用层处理
                解决方法就是循环处理：应用程序在处理从缓存读来的分组时，
            读完一条数据时，就应该循环读下一条数据，直到所有的数据都被处理；但是如何判断每条数据的长度呢？
        
        
                两种途径：
                1）格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，
            但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符；
        
                2）发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，       
            应用层处理时可以根据长度来判断每条数据的开始和结束。
        
                  
9.python的GIL
                GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，
            一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），
            使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，
            则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。
            多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，
            所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大            
        
        
10.进程之间如何进行通信？
            进程间通讯有多种方式，包括信号，管道，消息队列，信号量，共享内存，socket等
            
                    
11.什么是并发和并行？
            并发：交替做不同事的能力
            并行：同时做不同事的能力        
        
            你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
            你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
            你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
            
            并发的关键是你有处理多个任务的能力，不一定要同时。
            并行的关键是你有同时处理多个任务的能力。
            
            它们最关键的点就是：是否是『同时』。
                   
"""