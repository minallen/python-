import  time


"""
1.简述解释型编程语言和编译型编程语言？
    解释型：
        解释型语言编写的程序不需要编译，在执行的时候，
    专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行的时候才翻译。
    这样解释型语言每执行一次就要翻译一次，效率比较低。

    编译型:
        编译型语言写的程序执行之前，需要一个专门的编译过程，
    通过编译系统，把源高级程序编译成为机器语言文件，翻译只做了一次，
    运行时不需要翻译，所以编译型语言的程序执行效率高，但也不能一概而论


2.Python解释器种类以及特点？
    Cpython、IPython、PyPy、Jython、IronPython
    
    
3.位和字节的关系？
    bit：位，一个二进制数据0或1
    byte:字节，存储空间的基本计量单位
    关系：1 byte = 8 bit


4.b、B、KB、MB、GB 的关系？
    1GB=1024MB 1MB=1024KB 1KB=1024B


5.请至少列举5个 PEP8 规范？
    缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。
    每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。
    逗号、冒号、分号前不要加空格。
    函数命名使用全部小写的方式，可以使用下划线
    常量命名使用全部大写的方式，可以使用下划线。
 
 
6.列举python2和python3的区别
    1.python2 range(1,5) 返回的是列表，python3 返回的是迭代器
    2.python2 使用print 既可以用小括号，也可以空格
      python3必须使用小括号
    3.python2中使用ascii编码，python3使用utf-8编码
    4.python2中如果显示正常中文，引入coding声明，python3不需要
    5.python2中是raw_imput函数，python3中是input函数
    6.python2中unicode表示字符串序列，str表示字节序列
      python3中str表示字符串序列，byte表示字节序列    


7.xrange和range的区别？
    range:根据start与stop指定的范围以及step设定的步长，生成一个序列。
    xrange:用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。
    
    区别：要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。          


8.lambda匿名函数：
    通常在需要一个函数，但是又不想费神去命名一个函数的场合下使用


9.pass的作用
    不会执行任何操作
    保证格式完整
    保证语义完整


10.*arg和**kwarg作用
    *args和**kwargs主要用于函数定义。你可以将不定数量的参数传递给一个函数。
    *args：用来发送一个非键值对的可变数量的参数列表给一个函数
    **kwargs:允许你将不定长度的键值对，作为参数传递给一个函数
    
    
11.is和==的区别：
    ==：是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等
    is：比较判断的是对象间的唯一身份标识，也就是id是否相同。 
    
    
12.简述Python的深浅拷贝
    浅拷贝：拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已。
    深拷贝：外围和内部元素都进行了拷贝对象本身，而不是引用。
    
    
13.Python垃圾回收机制？
    python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，
    其中标记-清除和分代回收主要是为了处理循环引用的难题。
    
    1.引用计数算法
    当有1个变量保存了对象的引用时，此对象的引用计数就会加1

    当使用del删除变量指向的对象时，如果对象的引用计数不为1，
    比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，
    如果再调用1次del，此时会真的把对象进行删除
           
    2.标记-清楚机制
    基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，
    遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象
    打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。   

    3.分代技术

    分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，
    每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大
    而减小，存活时间通常利用经过几次垃圾回收来度量


14.Python的可变类型和不可变类型？
    1.不可变类型（数字、字符串、元组、不可变集合）

    不可变的分类中没有哪个对象类型支持原处修改，
    尽管我们总是可以运行表达式来创建新的对象并将其结果分配给变量。
    一般来说，不可变类型有某种完整性，保证这个对象不会被程序的其它部分改变。
    
    2.可变类型（列表、字典、可变集合）

    相反，可变的类型总是可以通过操作原处修改，而不是创建新的对象。
    尽管这样的可以复制，但原处修改支持直接修改。
    

15.求输出结果
    v = dict.fromkeys(['k1','k2'],[])
    print(v)    #{'k1': [], 'k2': []}
    v['k1'].append(666)
    print(v)    #{'k1': [666], 'k2': [666]}
    v['k1'] = 777
    print(v)    #{'k1': 777, 'k2': [666]}
    
    
16.列举常见的内置函数？
    input()
    slice()
    int()
    open()
    sum()
    format()
    compile()     
    
    
17.一行代码实现9*9乘法表

    print("\n".join
      ("\t".join(["%s*%s=%s" %(x,y,x*y) for y in range(1, x+1)]) for x in range(1, 10)
       )
    )
     
     
18.列举常用模块都有哪些？        
    time
    random
    os
    sys
    re
    logging
    hashlib


19.re的match和search区别？
    match()从开始位置匹配string 
    search()整个string查找匹配第一个。
    
 
20.正则表达式的贪婪和非贪婪匹配区别？
    （.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配
    （.*?）是非贪婪匹配，会把满足正则的尽可能少匹配
    
    
21.如何实现[‘1’,’2’,’3’]变成[1,2,3]  
    a = ['1','2','3']
    a_int = [int(i) for i in a]
    print(a_int)    #[1, 2, 3]    
    
    
    a = ['1','2','3']
    aa = []
    for i in a:
        if type(i) == str:
            aa.append(int(i))
    print(aa)                   #[1, 2, 3]
  
    
22.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?
    a = [i ** 2 for i in range(1,11)]
    print(a)   
    
  
23.谈谈你对闭包的理解？
    在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，
    并且外函数的返回值是内函数的引用。这样就构成了一个闭包。    
"""

